<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://xmlns.jcp.org/jsf/html"
      xmlns:f="http://xmlns.jcp.org/jsf/core"
      xmlns:p="http://primefaces.org/ui"
      xmlns:ui="http://xmlns.jcp.org/jsf/facelets"
      xmlns:composite="http://xmlns.jcp.org/jsf/composite">

<!-- 
    Componente reutilizável para exibição de avatars
    Referência: Regras de Avatar - project_rules.md
    Referência: Sistema de Temas Claros e Escuros - project_rules.md
-->

<composite:interface>
    <!-- Atributos obrigatórios -->
    <composite:attribute name="usuarioId" type="java.lang.Long" required="true"
                        shortDescription="ID do usuário para carregar o avatar" />
    
    <!-- Atributos opcionais -->
    <composite:attribute name="tamanho" type="java.lang.String" default="medio"
                        shortDescription="Tamanho do avatar: pequeno, medio, grande" />
    
    <composite:attribute name="mostrarNome" type="java.lang.Boolean" default="false"
                        shortDescription="Se deve mostrar o nome do usuário abaixo do avatar" />
    
    <composite:attribute name="clicavel" type="java.lang.Boolean" default="false"
                        shortDescription="Se o avatar deve ser clicável para ir ao perfil" />
    
    <composite:attribute name="editavel" type="java.lang.Boolean" default="false"
                        shortDescription="Se deve mostrar botão de edição (apenas para próprio usuário)" />
    
    <composite:attribute name="styleClass" type="java.lang.String" default=""
                        shortDescription="Classes CSS adicionais" />
    
    <composite:attribute name="style" type="java.lang.String" default=""
                        shortDescription="Estilos CSS inline adicionais" />
    
    <composite:attribute name="alt" type="java.lang.String" default="Avatar do usuário"
                        shortDescription="Texto alternativo para a imagem" />
    
    <composite:attribute name="placeholder" type="java.lang.String" default=""
                        shortDescription="Texto ou ícone para quando não há avatar" />
    
    <composite:attribute name="border" type="java.lang.Boolean" default="true"
                        shortDescription="Se deve mostrar borda ao redor do avatar" />
    
    <composite:attribute name="shadow" type="java.lang.Boolean" default="true"
                        shortDescription="Se deve mostrar sombra no avatar" />
    
    <composite:attribute name="hover" type="java.lang.Boolean" default="true"
                        shortDescription="Se deve ter efeito hover" />
</composite:interface>

<composite:implementation>
    
    <!-- CSS do componente -->
    <h:outputStylesheet>
        .avatar-component {
            display: inline-block;
            position: relative;
            text-align: center;
        }
        
        .avatar-image {
            border-radius: 50%;
            object-fit: cover;
            transition: all 0.3s ease;
            background: var(--avatar-bg, #f3f4f6);
        }
        
        .avatar-image.with-border {
            border: 2px solid var(--avatar-border, #e5e7eb);
        }
        
        .avatar-image.with-shadow {
            box-shadow: 0 2px 8px var(--avatar-shadow, rgba(0, 0, 0, 0.1));
        }
        
        .avatar-image.with-hover:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px var(--avatar-shadow-hover, rgba(0, 0, 0, 0.2));
        }
        
        .avatar-image.clicavel {
            cursor: pointer;
        }
        
        /* Tamanhos */
        .avatar-pequeno {
            width: 32px;
            height: 32px;
        }
        
        .avatar-medio {
            width: 64px;
            height: 64px;
        }
        
        .avatar-grande {
            width: 128px;
            height: 128px;
        }
        
        .avatar-extra-grande {
            width: 256px;
            height: 256px;
        }
        
        /* Placeholder */
        .avatar-placeholder {
            background: linear-gradient(135deg, 
                var(--avatar-placeholder-start, #f3f4f6), 
                var(--avatar-placeholder-end, #e5e7eb));
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--avatar-placeholder-text, #6b7280);
            font-weight: 500;
            border-radius: 50%;
        }
        
        .avatar-placeholder.avatar-pequeno {
            font-size: 0.75rem;
        }
        
        .avatar-placeholder.avatar-medio {
            font-size: 1rem;
        }
        
        .avatar-placeholder.avatar-grande {
            font-size: 1.5rem;
        }
        
        .avatar-placeholder.avatar-extra-grande {
            font-size: 2rem;
        }
        
        /* Nome do usuário */
        .avatar-nome {
            margin-top: 8px;
            font-size: 0.875rem;
            color: var(--text-secondary, #6b7280);
            font-weight: 500;
        }
        
        /* Botão de edição */
        .avatar-edit-btn {
            position: absolute;
            bottom: -5px;
            right: -5px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary-color, #3b82f6);
            color: white;
            border: 2px solid var(--background, white);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
        }
        
        .avatar-edit-btn:hover {
            background: var(--primary-color-dark, #2563eb);
            transform: scale(1.1);
        }
        
        /* Status online (futuro) */
        .avatar-status {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid var(--background, white);
        }
        
        .avatar-status.online {
            background: #10b981;
        }
        
        .avatar-status.offline {
            background: #6b7280;
        }
        
        .avatar-status.away {
            background: #f59e0b;
        }
        
        /* Tema escuro */
        .dark-theme .avatar-image.with-border {
            border-color: var(--avatar-border-dark, #374151);
        }
        
        .dark-theme .avatar-placeholder {
            background: linear-gradient(135deg, 
                var(--avatar-placeholder-start-dark, #374151), 
                var(--avatar-placeholder-end-dark, #4b5563));
            color: var(--avatar-placeholder-text-dark, #d1d5db);
        }
        
        .dark-theme .avatar-nome {
            color: var(--text-secondary-dark, #d1d5db);
        }
        
        .dark-theme .avatar-edit-btn {
            border-color: var(--background-dark, #111827);
        }
    </h:outputStylesheet>
    
    <!-- Lógica do componente -->
    <div class="avatar-component #{cc.attrs.styleClass}" style="#{cc.attrs.style}">
        
        <!-- Avatar com imagem -->
        <h:panelGroup rendered="#{avatarService.temAvatar(cc.attrs.usuarioId)}">
            <h:graphicImage value="#{avatarService.obterAvatarUsuario(cc.attrs.usuarioId, cc.attrs.tamanho)}"
                          styleClass="avatar-image avatar-#{cc.attrs.tamanho} #{cc.attrs.border ? 'with-border' : ''} #{cc.attrs.shadow ? 'with-shadow' : ''} #{cc.attrs.hover ? 'with-hover' : ''} #{cc.attrs.clicavel ? 'clicavel' : ''}"
                          alt="#{cc.attrs.alt}"
                          onclick="#{cc.attrs.clicavel ? 'window.location.href=\'/perfil/'.concat(cc.attrs.usuarioId).concat('\';') : ''}" />
        </h:panelGroup>
        
        <!-- Placeholder quando não há avatar -->
        <h:panelGroup rendered="#{!avatarService.temAvatar(cc.attrs.usuarioId)}">
            <div class="avatar-placeholder avatar-#{cc.attrs.tamanho} #{cc.attrs.border ? 'with-border' : ''} #{cc.attrs.shadow ? 'with-shadow' : ''} #{cc.attrs.hover ? 'with-hover' : ''} #{cc.attrs.clicavel ? 'clicavel' : ''}"
                 onclick="#{cc.attrs.clicavel ? 'window.location.href=\'/perfil/'.concat(cc.attrs.usuarioId).concat('\';') : ''}">
                
                <!-- Placeholder personalizado ou padrão -->
                <h:outputText value="#{cc.attrs.placeholder != '' ? cc.attrs.placeholder : usuarioService.obterIniciais(cc.attrs.usuarioId)}" 
                            rendered="#{cc.attrs.placeholder != '' or cc.attrs.tamanho != 'pequeno'}" />
                
                <!-- Ícone para avatars pequenos sem placeholder -->
                <i class="pi pi-user" 
                   rendered="#{cc.attrs.placeholder == '' and cc.attrs.tamanho == 'pequeno'}"></i>
            </div>
        </h:panelGroup>
        
        <!-- Botão de edição (apenas para próprio usuário) -->
        <h:panelGroup rendered="#{cc.attrs.editavel and authService.podeEditarPerfil(cc.attrs.usuarioId)}">
            <p:commandButton styleClass="avatar-edit-btn"
                           icon="pi pi-pencil"
                           title="Editar avatar"
                           action="/perfil/avatar?faces-redirect=true"
                           process="@none" />
        </h:panelGroup>
        
        <!-- Nome do usuário -->
        <h:panelGroup rendered="#{cc.attrs.mostrarNome}">
            <div class="avatar-nome">
                <h:outputText value="#{usuarioService.obterNomeCompleto(cc.attrs.usuarioId)}" />
            </div>
        </h:panelGroup>
        
    </div>
    
    <!-- JavaScript para funcionalidades extras -->
    <h:outputScript>
        // Lazy loading para avatars
        function setupAvatarLazyLoading() {
            const avatarImages = document.querySelectorAll('.avatar-image');
            
            if ('IntersectionObserver' in window) {
                const imageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                                imageObserver.unobserve(img);
                            }
                        }
                    });
                });
                
                avatarImages.forEach(img => imageObserver.observe(img));
            }
        }
        
        // Fallback para erro de carregamento
        function setupAvatarErrorHandling() {
            const avatarImages = document.querySelectorAll('.avatar-image');
            
            avatarImages.forEach(img => {
                img.addEventListener('error', function() {
                    // Substituir por placeholder em caso de erro
                    const placeholder = this.parentNode.querySelector('.avatar-placeholder');
                    if (placeholder) {
                        this.style.display = 'none';
                        placeholder.style.display = 'flex';
                    } else {
                        // Criar placeholder dinamicamente
                        const newPlaceholder = document.createElement('div');
                        newPlaceholder.className = this.className.replace('avatar-image', 'avatar-placeholder');
                        newPlaceholder.innerHTML = '<i class="pi pi-user"></i>';
                        this.parentNode.replaceChild(newPlaceholder, this);
                    }
                });
            });
        }
        
        // Tooltip com informações do usuário
        function setupAvatarTooltips() {
            const avatars = document.querySelectorAll('.avatar-component');
            
            avatars.forEach(avatar => {
                if (avatar.dataset.tooltip) {
                    avatar.setAttribute('title', avatar.dataset.tooltip);
                }
            });
        }
        
        // Inicializar funcionalidades
        document.addEventListener('DOMContentLoaded', function() {
            setupAvatarLazyLoading();
            setupAvatarErrorHandling();
            setupAvatarTooltips();
        });
        
        // Reinicializar após atualizações AJAX
        if (typeof PrimeFaces !== 'undefined') {
            PrimeFaces.ajax.addOnCompleteHandler(function() {
                setTimeout(function() {
                    setupAvatarLazyLoading();
                    setupAvatarErrorHandling();
                    setupAvatarTooltips();
                }, 100);
            });
        }
    </h:outputScript>
    
</composite:implementation>

</html>