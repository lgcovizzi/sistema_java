<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuthController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sistema-java</a> &gt; <a href="index.source.html" class="el_package">com.sistema.controller</a> &gt; <span class="el_source">AuthController.java</span></div><h1>AuthController.java</h1><pre class="source lang-java linenums">package com.sistema.controller;

import com.sistema.entity.User;
import com.sistema.service.AuthService;
import com.sistema.service.JwtService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Controlador REST para operações de autenticação e autorização.
 * Fornece endpoints para login, registro, refresh de tokens e gerenciamento de usuários.
 */
@RestController
@RequestMapping(&quot;/api/auth&quot;)
@CrossOrigin(origins = &quot;*&quot;, maxAge = 3600)
public class AuthController {

<span class="fc" id="L35">    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);</span>

    private final AuthService authService;
    private final JwtService jwtService;

    @Autowired
<span class="fc" id="L41">    public AuthController(AuthService authService, JwtService jwtService) {</span>
<span class="fc" id="L42">        this.authService = authService;</span>
<span class="fc" id="L43">        this.jwtService = jwtService;</span>
<span class="fc" id="L44">    }</span>

    /**
     * Endpoint para autenticação de usuários.
     * 
     * @param loginRequest dados de login
     * @param httpRequest requisição HTTP
     * @return tokens JWT e informações do usuário
     */
    @PostMapping(&quot;/login&quot;)
    public ResponseEntity&lt;?&gt; login(@Valid @RequestBody LoginRequest loginRequest, HttpServletRequest httpRequest) {
        try {
<span class="nc" id="L56">            Map&lt;String, Object&gt; authResponse = authService.authenticate(</span>
<span class="nc" id="L57">                    loginRequest.getUsernameOrEmail(),</span>
<span class="nc" id="L58">                    loginRequest.getPassword(),</span>
                    httpRequest
            );
            
<span class="nc" id="L62">            logger.info(&quot;Login realizado com sucesso para: {}&quot;, loginRequest.getUsernameOrEmail());</span>
<span class="nc" id="L63">            return ResponseEntity.ok(authResponse);</span>
            
<span class="nc" id="L65">        } catch (Exception e) {</span>
<span class="nc" id="L66">            logger.warn(&quot;Falha no login para: {}&quot;, loginRequest.getUsernameOrEmail());</span>
<span class="nc" id="L67">            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)</span>
<span class="nc" id="L68">                    .body(createErrorResponse(&quot;Credenciais inválidas&quot;, &quot;INVALID_CREDENTIALS&quot;));</span>
        }
    }

    /**
     * Endpoint para registro de novos usuários.
     * 
     * @param registerRequest dados de registro
     * @param httpRequest requisição HTTP
     * @return tokens JWT e informações do usuário criado
     */
    @PostMapping(&quot;/register&quot;)
    public ResponseEntity&lt;?&gt; register(@Valid @RequestBody RegisterRequest registerRequest, HttpServletRequest httpRequest) {
        try {
<span class="nc" id="L82">            Map&lt;String, Object&gt; authResponse = authService.registerAndAuthenticate(</span>
<span class="nc" id="L83">                    registerRequest.getUsername(),</span>
<span class="nc" id="L84">                    registerRequest.getEmail(),</span>
<span class="nc" id="L85">                    registerRequest.getPassword(),</span>
<span class="nc" id="L86">                    registerRequest.getFirstName(),</span>
<span class="nc" id="L87">                    registerRequest.getLastName(),</span>
                    httpRequest
            );
            
<span class="nc" id="L91">            logger.info(&quot;Usuário registrado com sucesso: {}&quot;, registerRequest.getUsername());</span>
<span class="nc" id="L92">            return ResponseEntity.status(HttpStatus.CREATED).body(authResponse);</span>
            
<span class="nc" id="L94">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L95">            logger.warn(&quot;Erro no registro: {}&quot;, e.getMessage());</span>
<span class="nc" id="L96">            return ResponseEntity.status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L97">                    .body(createErrorResponse(e.getMessage(), &quot;REGISTRATION_ERROR&quot;));</span>
<span class="nc" id="L98">        } catch (Exception e) {</span>
<span class="nc" id="L99">            logger.error(&quot;Erro interno no registro&quot;, e);</span>
<span class="nc" id="L100">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L101">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint para renovação de token de acesso.
     * 
     * @param refreshRequest dados do refresh token
     * @param httpRequest requisição HTTP
     * @return novo token de acesso
     */
    @PostMapping(&quot;/refresh&quot;)
    public ResponseEntity&lt;?&gt; refreshToken(@Valid @RequestBody RefreshTokenRequest refreshRequest, HttpServletRequest httpRequest) {
        try {
<span class="nc" id="L115">            Map&lt;String, Object&gt; refreshResponse = authService.refreshAccessToken(</span>
<span class="nc" id="L116">                    refreshRequest.getRefreshToken(),</span>
                    httpRequest
            );
            
<span class="nc" id="L120">            return ResponseEntity.ok(refreshResponse);</span>
            
<span class="nc" id="L122">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L123">            logger.warn(&quot;Refresh token inválido: {}&quot;, e.getMessage());</span>
<span class="nc" id="L124">            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)</span>
<span class="nc" id="L125">                    .body(createErrorResponse(&quot;Refresh token inválido&quot;, &quot;INVALID_REFRESH_TOKEN&quot;));</span>
<span class="nc" id="L126">        } catch (Exception e) {</span>
<span class="nc" id="L127">            logger.error(&quot;Erro no refresh do token&quot;, e);</span>
<span class="nc" id="L128">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L129">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint para logout (invalidação de token).
     * 
     * @param logoutRequest dados do logout
     * @return confirmação de logout
     */
    @PostMapping(&quot;/logout&quot;)
    public ResponseEntity&lt;?&gt; logout(@RequestBody(required = false) LogoutRequest logoutRequest) {
        try {
<span class="nc bnc" id="L142" title="All 2 branches missed.">            String refreshToken = logoutRequest != null ? logoutRequest.getRefreshToken() : null;</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            boolean revokeAll = logoutRequest != null ? logoutRequest.isRevokeAll() : false;</span>
            
<span class="nc" id="L145">            authService.logout(refreshToken, revokeAll);</span>
            
<span class="nc" id="L147">            logger.info(&quot;Logout realizado com sucesso&quot;);</span>
            
<span class="nc" id="L149">            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</span>
<span class="nc" id="L150">            response.put(&quot;message&quot;, &quot;Logout realizado com sucesso&quot;);</span>
<span class="nc" id="L151">            response.put(&quot;timestamp&quot;, System.currentTimeMillis());</span>
            
<span class="nc" id="L153">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L155">        } catch (Exception e) {</span>
<span class="nc" id="L156">            logger.error(&quot;Erro durante logout&quot;, e);</span>
<span class="nc" id="L157">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L158">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint para obter informações do usuário autenticado.
     * 
     * @return informações do usuário
     */
    @GetMapping(&quot;/me&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public ResponseEntity&lt;?&gt; getCurrentUser() {
        try {
<span class="nc" id="L171">            Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="nc" id="L172">            User user = (User) auth.getPrincipal();</span>
            
<span class="nc" id="L174">            Map&lt;String, Object&gt; userInfo = new HashMap&lt;&gt;();</span>
<span class="nc" id="L175">            userInfo.put(&quot;id&quot;, user.getId());</span>
<span class="nc" id="L176">            userInfo.put(&quot;username&quot;, user.getUsername());</span>
<span class="nc" id="L177">            userInfo.put(&quot;email&quot;, user.getEmail());</span>
<span class="nc" id="L178">            userInfo.put(&quot;fullName&quot;, user.getFullName());</span>
<span class="nc" id="L179">            userInfo.put(&quot;roles&quot;, user.getRoles());</span>
<span class="nc" id="L180">            userInfo.put(&quot;lastLogin&quot;, user.getLastLogin());</span>
<span class="nc" id="L181">            userInfo.put(&quot;createdAt&quot;, user.getCreatedAt());</span>
            
<span class="nc" id="L183">            return ResponseEntity.ok(userInfo);</span>
            
<span class="nc" id="L185">        } catch (Exception e) {</span>
<span class="nc" id="L186">            logger.error(&quot;Erro ao obter informações do usuário&quot;, e);</span>
<span class="nc" id="L187">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L188">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint para alteração de senha.
     * 
     * @param changePasswordRequest dados para alteração de senha
     * @return confirmação da alteração
     */
    @PostMapping(&quot;/change-password&quot;)
    @PreAuthorize(&quot;isAuthenticated()&quot;)
    public ResponseEntity&lt;?&gt; changePassword(@Valid @RequestBody ChangePasswordRequest changePasswordRequest) {
        try {
<span class="nc" id="L202">            Authentication auth = SecurityContextHolder.getContext().getAuthentication();</span>
<span class="nc" id="L203">            String username = auth.getName();</span>
            
<span class="nc" id="L205">            authService.changePassword(</span>
                    username,
<span class="nc" id="L207">                    changePasswordRequest.getCurrentPassword(),</span>
<span class="nc" id="L208">                    changePasswordRequest.getNewPassword()</span>
            );
            
<span class="nc" id="L211">            logger.info(&quot;Senha alterada para usuário: {}&quot;, username);</span>
            
<span class="nc" id="L213">            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</span>
<span class="nc" id="L214">            response.put(&quot;message&quot;, &quot;Senha alterada com sucesso&quot;);</span>
<span class="nc" id="L215">            response.put(&quot;timestamp&quot;, System.currentTimeMillis());</span>
            
<span class="nc" id="L217">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L219">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L220">            return ResponseEntity.status(HttpStatus.BAD_REQUEST)</span>
<span class="nc" id="L221">                    .body(createErrorResponse(e.getMessage(), &quot;INVALID_PASSWORD&quot;));</span>
<span class="nc" id="L222">        } catch (Exception e) {</span>
<span class="nc" id="L223">            logger.error(&quot;Erro ao alterar senha&quot;, e);</span>
<span class="nc" id="L224">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L225">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint para validação de token.
     * 
     * @param validateTokenRequest dados do token
     * @return informações sobre a validade do token
     */
    @PostMapping(&quot;/validate-token&quot;)
    public ResponseEntity&lt;?&gt; validateToken(@Valid @RequestBody ValidateTokenRequest validateTokenRequest) {
        try {
<span class="nc" id="L238">            String token = validateTokenRequest.getToken();</span>
            
<span class="nc" id="L240">            Map&lt;String, Object&gt; tokenInfo = jwtService.getTokenInfo(token);</span>
<span class="nc" id="L241">            boolean isValid = jwtService.isValidAccessToken(token);</span>
            
<span class="nc" id="L243">            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</span>
<span class="nc" id="L244">            response.put(&quot;valid&quot;, isValid);</span>
<span class="nc" id="L245">            response.put(&quot;tokenInfo&quot;, tokenInfo);</span>
            
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (isValid) {</span>
<span class="nc" id="L248">                response.put(&quot;timeToExpiration&quot;, jwtService.getTimeToExpiration(token));</span>
            }
            
<span class="nc" id="L251">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L253">        } catch (Exception e) {</span>
<span class="nc" id="L254">            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</span>
<span class="nc" id="L255">            response.put(&quot;valid&quot;, false);</span>
<span class="nc" id="L256">            response.put(&quot;error&quot;, e.getMessage());</span>
            
<span class="nc" id="L258">            return ResponseEntity.ok(response);</span>
        }
    }

    /**
     * Endpoint administrativo para listar usuários.
     * 
     * @return lista de usuários
     */
    @GetMapping(&quot;/users&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;?&gt; getUsers(@RequestParam(required = false) String search) {
        try {
            List&lt;User&gt; users;
            
<span class="nc bnc" id="L273" title="All 4 branches missed.">            if (search != null &amp;&amp; !search.trim().isEmpty()) {</span>
<span class="nc" id="L274">                users = authService.searchUsers(search.trim());</span>
            } else {
<span class="nc" id="L276">                users = authService.findActiveUsers();</span>
            }
            
<span class="nc" id="L279">            return ResponseEntity.ok(users);</span>
            
<span class="nc" id="L281">        } catch (Exception e) {</span>
<span class="nc" id="L282">            logger.error(&quot;Erro ao listar usuários&quot;, e);</span>
<span class="nc" id="L283">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L284">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint administrativo para obter estatísticas de usuários.
     * 
     * @return estatísticas dos usuários
     */
    @GetMapping(&quot;/statistics&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;?&gt; getUserStatistics() {
        try {
<span class="nc" id="L297">            Map&lt;String, Object&gt; statistics = authService.getUserStatistics();</span>
<span class="nc" id="L298">            return ResponseEntity.ok(statistics);</span>
            
<span class="nc" id="L300">        } catch (Exception e) {</span>
<span class="nc" id="L301">            logger.error(&quot;Erro ao obter estatísticas&quot;, e);</span>
<span class="nc" id="L302">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L303">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Endpoint administrativo para ativar/desativar usuário.
     * 
     * @param userId ID do usuário
     * @param enableUserRequest dados para ativação/desativação
     * @return confirmação da operação
     */
    @PutMapping(&quot;/users/{userId}/status&quot;)
    @PreAuthorize(&quot;hasRole('ADMIN')&quot;)
    public ResponseEntity&lt;?&gt; setUserStatus(@PathVariable Long userId, 
                                          @Valid @RequestBody EnableUserRequest enableUserRequest) {
        try {
<span class="nc" id="L319">            Optional&lt;User&gt; userOpt = authService.findById(userId);</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (userOpt.isEmpty()) {</span>
<span class="nc" id="L321">                return ResponseEntity.status(HttpStatus.NOT_FOUND)</span>
<span class="nc" id="L322">                        .body(createErrorResponse(&quot;Usuário não encontrado&quot;, &quot;USER_NOT_FOUND&quot;));</span>
            }
            
<span class="nc" id="L325">            authService.setUserEnabled(userId, enableUserRequest.isEnabled());</span>
            
<span class="nc" id="L327">            Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();</span>
<span class="nc" id="L328">            response.put(&quot;message&quot;, &quot;Status do usuário atualizado com sucesso&quot;);</span>
<span class="nc" id="L329">            response.put(&quot;userId&quot;, userId);</span>
<span class="nc" id="L330">            response.put(&quot;enabled&quot;, enableUserRequest.isEnabled());</span>
            
<span class="nc" id="L332">            return ResponseEntity.ok(response);</span>
            
<span class="nc" id="L334">        } catch (Exception e) {</span>
<span class="nc" id="L335">            logger.error(&quot;Erro ao alterar status do usuário&quot;, e);</span>
<span class="nc" id="L336">            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)</span>
<span class="nc" id="L337">                    .body(createErrorResponse(&quot;Erro interno do servidor&quot;, &quot;INTERNAL_ERROR&quot;));</span>
        }
    }

    /**
     * Cria uma resposta de erro padronizada.
     * 
     * @param message mensagem de erro
     * @param errorCode código do erro
     * @return mapa com dados do erro
     */
    private Map&lt;String, Object&gt; createErrorResponse(String message, String errorCode) {
<span class="nc" id="L349">        Map&lt;String, Object&gt; error = new HashMap&lt;&gt;();</span>
<span class="nc" id="L350">        error.put(&quot;error&quot;, true);</span>
<span class="nc" id="L351">        error.put(&quot;message&quot;, message);</span>
<span class="nc" id="L352">        error.put(&quot;errorCode&quot;, errorCode);</span>
<span class="nc" id="L353">        error.put(&quot;timestamp&quot;, System.currentTimeMillis());</span>
<span class="nc" id="L354">        return error;</span>
    }

    // Classes de Request DTOs
    
<span class="nc" id="L359">    public static class LoginRequest {</span>
        @NotBlank(message = &quot;Username ou email é obrigatório&quot;)
        private String usernameOrEmail;
        
        @NotBlank(message = &quot;Password é obrigatório&quot;)
        private String password;
        
        // Getters e Setters
<span class="nc" id="L367">        public String getUsernameOrEmail() { return usernameOrEmail; }</span>
<span class="nc" id="L368">        public void setUsernameOrEmail(String usernameOrEmail) { this.usernameOrEmail = usernameOrEmail; }</span>
<span class="nc" id="L369">        public String getPassword() { return password; }</span>
<span class="nc" id="L370">        public void setPassword(String password) { this.password = password; }</span>
    }
    
<span class="nc" id="L373">    public static class RegisterRequest {</span>
        @NotBlank(message = &quot;Username é obrigatório&quot;)
        @Size(min = 3, max = 50, message = &quot;Username deve ter entre 3 e 50 caracteres&quot;)
        private String username;
        
        @NotBlank(message = &quot;Email é obrigatório&quot;)
        @Email(message = &quot;Email deve ser válido&quot;)
        private String email;
        
        @NotBlank(message = &quot;Password é obrigatório&quot;)
        @Size(min = 6, message = &quot;Password deve ter pelo menos 6 caracteres&quot;)
        private String password;
        
        private String firstName;
        private String lastName;
        
        // Getters e Setters
<span class="nc" id="L390">        public String getUsername() { return username; }</span>
<span class="nc" id="L391">        public void setUsername(String username) { this.username = username; }</span>
<span class="nc" id="L392">        public String getEmail() { return email; }</span>
<span class="nc" id="L393">        public void setEmail(String email) { this.email = email; }</span>
<span class="nc" id="L394">        public String getPassword() { return password; }</span>
<span class="nc" id="L395">        public void setPassword(String password) { this.password = password; }</span>
<span class="nc" id="L396">        public String getFirstName() { return firstName; }</span>
<span class="nc" id="L397">        public void setFirstName(String firstName) { this.firstName = firstName; }</span>
<span class="nc" id="L398">        public String getLastName() { return lastName; }</span>
<span class="nc" id="L399">        public void setLastName(String lastName) { this.lastName = lastName; }</span>
    }
    
<span class="nc" id="L402">    public static class RefreshTokenRequest {</span>
        @NotBlank(message = &quot;Refresh token é obrigatório&quot;)
        private String refreshToken;
        
        // Getters e Setters
<span class="nc" id="L407">        public String getRefreshToken() { return refreshToken; }</span>
<span class="nc" id="L408">        public void setRefreshToken(String refreshToken) { this.refreshToken = refreshToken; }</span>
    }
    
<span class="nc" id="L411">    public static class ChangePasswordRequest {</span>
        @NotBlank(message = &quot;Senha atual é obrigatória&quot;)
        private String currentPassword;
        
        @NotBlank(message = &quot;Nova senha é obrigatória&quot;)
        @Size(min = 6, message = &quot;Nova senha deve ter pelo menos 6 caracteres&quot;)
        private String newPassword;
        
        // Getters e Setters
<span class="nc" id="L420">        public String getCurrentPassword() { return currentPassword; }</span>
<span class="nc" id="L421">        public void setCurrentPassword(String currentPassword) { this.currentPassword = currentPassword; }</span>
<span class="nc" id="L422">        public String getNewPassword() { return newPassword; }</span>
<span class="nc" id="L423">        public void setNewPassword(String newPassword) { this.newPassword = newPassword; }</span>
    }
    
<span class="nc" id="L426">    public static class ValidateTokenRequest {</span>
        @NotBlank(message = &quot;Token é obrigatório&quot;)
        private String token;
        
        // Getters e Setters
<span class="nc" id="L431">        public String getToken() { return token; }</span>
<span class="nc" id="L432">        public void setToken(String token) { this.token = token; }</span>
    }
    
<span class="nc" id="L435">    public static class LogoutRequest {</span>
        private String refreshToken;
<span class="nc" id="L437">        private boolean revokeAll = false;</span>
        
        // Getters e Setters
<span class="nc" id="L440">        public String getRefreshToken() { return refreshToken; }</span>
<span class="nc" id="L441">        public void setRefreshToken(String refreshToken) { this.refreshToken = refreshToken; }</span>
<span class="nc" id="L442">        public boolean isRevokeAll() { return revokeAll; }</span>
<span class="nc" id="L443">        public void setRevokeAll(boolean revokeAll) { this.revokeAll = revokeAll; }</span>
    }
    
<span class="nc" id="L446">    public static class EnableUserRequest {</span>
        private boolean enabled;
        
        // Getters e Setters
<span class="nc" id="L450">        public boolean isEnabled() { return enabled; }</span>
<span class="nc" id="L451">        public void setEnabled(boolean enabled) { this.enabled = enabled; }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>