<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RefreshTokenService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sistema-java</a> &gt; <a href="index.source.html" class="el_package">com.sistema.service</a> &gt; <span class="el_source">RefreshTokenService.java</span></div><h1>RefreshTokenService.java</h1><pre class="source lang-java linenums">package com.sistema.service;

import com.sistema.entity.RefreshToken;
import com.sistema.entity.User;
import com.sistema.repository.RefreshTokenRepository;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.List;
import java.util.Optional;

/**
 * Serviço para gerenciar tokens de refresh.
 * Responsável pela criação, validação, renovação e limpeza de tokens de refresh.
 */
@Service
@Transactional
<span class="nc" id="L27">public class RefreshTokenService {</span>

<span class="nc" id="L29">    private static final Logger logger = LoggerFactory.getLogger(RefreshTokenService.class);</span>
<span class="nc" id="L30">    private static final SecureRandom secureRandom = new SecureRandom();</span>
    
    // Configurações
    @Value(&quot;${app.jwt.refresh-expiration:15552000}&quot;) // 6 meses em segundos
    private long refreshTokenExpiration;
    
    @Value(&quot;${app.refresh-token.max-per-user:5}&quot;)
    private int maxTokensPerUser;
    
    @Value(&quot;${app.refresh-token.cleanup-enabled:true}&quot;)
    private boolean cleanupEnabled;

    @Autowired
    private RefreshTokenRepository refreshTokenRepository;

    /**
     * Cria um novo token de refresh para o usuário.
     *
     * @param user O usuário
     * @param request A requisição HTTP para extrair informações do dispositivo
     * @return O token de refresh criado
     */
    public RefreshToken createRefreshToken(User user, HttpServletRequest request) {
<span class="nc" id="L53">        logger.debug(&quot;Criando refresh token para usuário: {}&quot;, user.getUsername());</span>
        
        // Limita o número de tokens por usuário
<span class="nc" id="L56">        limitTokensPerUser(user);</span>
        
        // Gera token único
<span class="nc" id="L59">        String token = generateSecureToken();</span>
        
        // Calcula data de expiração (6 meses)
<span class="nc" id="L62">        LocalDateTime expiresAt = LocalDateTime.now().plusSeconds(refreshTokenExpiration);</span>
        
        // Extrai informações da requisição
<span class="nc" id="L65">        String deviceInfo = extractDeviceInfo(request);</span>
<span class="nc" id="L66">        String ipAddress = extractIpAddress(request);</span>
<span class="nc" id="L67">        String userAgent = extractUserAgent(request);</span>
        
        // Cria o refresh token
<span class="nc" id="L70">        RefreshToken refreshToken = new RefreshToken(</span>
            token, user, expiresAt, deviceInfo, ipAddress, userAgent
        );
        
<span class="nc" id="L74">        refreshToken.setLastUsedAt(LocalDateTime.now());</span>
        
<span class="nc" id="L76">        RefreshToken saved = refreshTokenRepository.save(refreshToken);</span>
<span class="nc" id="L77">        logger.info(&quot;Refresh token criado com sucesso para usuário: {} (ID: {})&quot;, user.getUsername(), saved.getId());</span>
        
<span class="nc" id="L79">        return saved;</span>
    }

    /**
     * Busca e valida um token de refresh.
     *
     * @param token O valor do token
     * @return Optional contendo o RefreshToken se válido
     */
    public Optional&lt;RefreshToken&gt; findValidRefreshToken(String token) {
<span class="nc bnc" id="L89" title="All 4 branches missed.">        if (token == null || token.trim().isEmpty()) {</span>
<span class="nc" id="L90">            return Optional.empty();</span>
        }
        
<span class="nc" id="L93">        Optional&lt;RefreshToken&gt; refreshToken = refreshTokenRepository.findValidByToken(token, LocalDateTime.now());</span>
        
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (refreshToken.isPresent()) {</span>
            // Atualiza último uso
<span class="nc" id="L97">            refreshToken.get().updateLastUsed();</span>
<span class="nc" id="L98">            refreshTokenRepository.save(refreshToken.get());</span>
<span class="nc" id="L99">            logger.debug(&quot;Refresh token válido encontrado e atualizado&quot;);</span>
        } else {
<span class="nc" id="L101">            logger.debug(&quot;Refresh token inválido ou expirado: {}&quot;, token.substring(0, Math.min(token.length(), 10)) + &quot;...&quot;);</span>
        }
        
<span class="nc" id="L104">        return refreshToken;</span>
    }

    /**
     * Revoga um token de refresh específico.
     *
     * @param token O valor do token
     * @return true se o token foi revogado com sucesso
     */
    public boolean revokeRefreshToken(String token) {
<span class="nc" id="L114">        Optional&lt;RefreshToken&gt; refreshToken = refreshTokenRepository.findByToken(token);</span>
        
<span class="nc bnc" id="L116" title="All 4 branches missed.">        if (refreshToken.isPresent() &amp;&amp; !refreshToken.get().getIsRevoked()) {</span>
<span class="nc" id="L117">            refreshToken.get().revoke();</span>
<span class="nc" id="L118">            refreshTokenRepository.save(refreshToken.get());</span>
<span class="nc" id="L119">            logger.info(&quot;Refresh token revogado: {}&quot;, refreshToken.get().getId());</span>
<span class="nc" id="L120">            return true;</span>
        }
        
<span class="nc" id="L123">        return false;</span>
    }

    /**
     * Revoga todos os tokens de refresh de um usuário.
     *
     * @param user O usuário
     * @return Número de tokens revogados
     */
    public int revokeAllUserTokens(User user) {
<span class="nc" id="L133">        int revokedCount = refreshTokenRepository.revokeAllByUser(user);</span>
<span class="nc" id="L134">        logger.info(&quot;Revogados {} refresh tokens do usuário: {}&quot;, revokedCount, user.getUsername());</span>
<span class="nc" id="L135">        return revokedCount;</span>
    }

    /**
     * Revoga todos os tokens de um usuário exceto o token atual.
     *
     * @param user O usuário
     * @param currentToken Token atual a ser preservado
     * @return Número de tokens revogados
     */
    public int revokeOtherUserTokens(User user, String currentToken) {
<span class="nc" id="L146">        int revokedCount = refreshTokenRepository.revokeAllByUserExcept(user, currentToken);</span>
<span class="nc" id="L147">        logger.info(&quot;Revogados {} outros refresh tokens do usuário: {}&quot;, revokedCount, user.getUsername());</span>
<span class="nc" id="L148">        return revokedCount;</span>
    }

    /**
     * Lista todos os tokens válidos de um usuário.
     *
     * @param user O usuário
     * @return Lista de tokens válidos
     */
    public List&lt;RefreshToken&gt; getUserValidTokens(User user) {
<span class="nc" id="L158">        return refreshTokenRepository.findValidByUser(user, LocalDateTime.now());</span>
    }

    /**
     * Obtém estatísticas de tokens de um usuário.
     *
     * @param user O usuário
     * @return Array com [total, válidos, expirados, revogados]
     */
    public long[] getUserTokenStats(User user) {
<span class="nc" id="L168">        Object[] stats = refreshTokenRepository.getTokenStatsByUser(user, LocalDateTime.now());</span>
<span class="nc" id="L169">        return new long[] {</span>
<span class="nc" id="L170">            ((Number) stats[0]).longValue(), // total</span>
<span class="nc" id="L171">            ((Number) stats[1]).longValue(), // válidos</span>
<span class="nc" id="L172">            ((Number) stats[2]).longValue(), // expirados</span>
<span class="nc" id="L173">            ((Number) stats[3]).longValue()  // revogados</span>
        };
    }

    /**
     * Verifica se o usuário atingiu o limite de tokens.
     *
     * @param user O usuário
     * @return true se atingiu o limite
     */
    public boolean hasReachedTokenLimit(User user) {
<span class="nc" id="L184">        long validTokens = refreshTokenRepository.countValidByUser(user, LocalDateTime.now());</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        return validTokens &gt;= maxTokensPerUser;</span>
    }

    /**
     * Limita o número de tokens por usuário, removendo os mais antigos se necessário.
     *
     * @param user O usuário
     */
    private void limitTokensPerUser(User user) {
<span class="nc" id="L194">        List&lt;RefreshToken&gt; validTokens = refreshTokenRepository.findValidByUser(user, LocalDateTime.now());</span>
        
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (validTokens.size() &gt;= maxTokensPerUser) {</span>
            // Remove os tokens mais antigos
<span class="nc" id="L198">            int tokensToRemove = validTokens.size() - maxTokensPerUser + 1;</span>
            
<span class="nc bnc" id="L200" title="All 2 branches missed.">            for (int i = validTokens.size() - tokensToRemove; i &lt; validTokens.size(); i++) {</span>
<span class="nc" id="L201">                RefreshToken tokenToRevoke = validTokens.get(i);</span>
<span class="nc" id="L202">                tokenToRevoke.revoke();</span>
<span class="nc" id="L203">                refreshTokenRepository.save(tokenToRevoke);</span>
            }
            
<span class="nc" id="L206">            logger.info(&quot;Removidos {} tokens antigos do usuário: {}&quot;, tokensToRemove, user.getUsername());</span>
        }
<span class="nc" id="L208">    }</span>

    /**
     * Gera um token seguro aleatório.
     *
     * @return Token seguro em Base64
     */
    private String generateSecureToken() {
<span class="nc" id="L216">        byte[] randomBytes = new byte[64]; // 512 bits</span>
<span class="nc" id="L217">        secureRandom.nextBytes(randomBytes);</span>
<span class="nc" id="L218">        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);</span>
    }

    /**
     * Extrai informações do dispositivo da requisição.
     *
     * @param request A requisição HTTP
     * @return Informações do dispositivo
     */
    private String extractDeviceInfo(HttpServletRequest request) {
<span class="nc" id="L228">        String userAgent = request.getHeader(&quot;User-Agent&quot;);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (userAgent == null) {</span>
<span class="nc" id="L230">            return &quot;Unknown Device&quot;;</span>
        }
        
<span class="nc" id="L233">        userAgent = userAgent.toLowerCase();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (userAgent.contains(&quot;mobile&quot;)) {</span>
<span class="nc" id="L235">            return &quot;Mobile Device&quot;;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        } else if (userAgent.contains(&quot;tablet&quot;)) {</span>
<span class="nc" id="L237">            return &quot;Tablet&quot;;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        } else if (userAgent.contains(&quot;postman&quot;)) {</span>
<span class="nc" id="L239">            return &quot;Postman&quot;;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">        } else if (userAgent.contains(&quot;curl&quot;)) {</span>
<span class="nc" id="L241">            return &quot;cURL&quot;;</span>
        } else {
<span class="nc" id="L243">            return &quot;Desktop&quot;;</span>
        }
    }

    /**
     * Extrai o endereço IP da requisição.
     *
     * @param request A requisição HTTP
     * @return Endereço IP
     */
    private String extractIpAddress(HttpServletRequest request) {
<span class="nc" id="L254">        String xForwardedFor = request.getHeader(&quot;X-Forwarded-For&quot;);</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (xForwardedFor != null &amp;&amp; !xForwardedFor.isEmpty()) {</span>
<span class="nc" id="L256">            return xForwardedFor.split(&quot;,&quot;)[0].trim();</span>
        }
        
<span class="nc" id="L259">        String xRealIp = request.getHeader(&quot;X-Real-IP&quot;);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">        if (xRealIp != null &amp;&amp; !xRealIp.isEmpty()) {</span>
<span class="nc" id="L261">            return xRealIp;</span>
        }
        
<span class="nc" id="L264">        return request.getRemoteAddr();</span>
    }

    /**
     * Extrai o User-Agent da requisição.
     *
     * @param request A requisição HTTP
     * @return User-Agent
     */
    private String extractUserAgent(HttpServletRequest request) {
<span class="nc" id="L274">        String userAgent = request.getHeader(&quot;User-Agent&quot;);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        return userAgent != null ? userAgent : &quot;Unknown&quot;;</span>
    }

    /**
     * Limpeza automática de tokens expirados e revogados antigos.
     * Executa diariamente às 2:00 AM.
     */
    @Scheduled(cron = &quot;0 0 2 * * *&quot;)
    public void cleanupExpiredTokens() {
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (!cleanupEnabled) {</span>
<span class="nc" id="L285">            return;</span>
        }
        
<span class="nc" id="L288">        logger.info(&quot;Iniciando limpeza automática de refresh tokens&quot;);</span>
        
        try {
            // Remove tokens expirados
<span class="nc" id="L292">            int expiredRemoved = refreshTokenRepository.deleteExpiredTokens(LocalDateTime.now());</span>
            
            // Remove tokens revogados há mais de 30 dias
<span class="nc" id="L295">            LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);</span>
<span class="nc" id="L296">            int revokedRemoved = refreshTokenRepository.deleteOldRevokedTokens(cutoffDate);</span>
            
<span class="nc" id="L298">            logger.info(&quot;Limpeza concluída: {} tokens expirados e {} tokens revogados antigos removidos&quot;, </span>
<span class="nc" id="L299">                       expiredRemoved, revokedRemoved);</span>
            
<span class="nc" id="L301">        } catch (Exception e) {</span>
<span class="nc" id="L302">            logger.error(&quot;Erro durante limpeza automática de tokens: {}&quot;, e.getMessage(), e);</span>
<span class="nc" id="L303">        }</span>
<span class="nc" id="L304">    }</span>

    /**
     * Limpeza manual de tokens.
     *
     * @return Número total de tokens removidos
     */
    public int manualCleanup() {
<span class="nc" id="L312">        logger.info(&quot;Iniciando limpeza manual de refresh tokens&quot;);</span>
        
<span class="nc" id="L314">        int expiredRemoved = refreshTokenRepository.deleteExpiredTokens(LocalDateTime.now());</span>
<span class="nc" id="L315">        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);</span>
<span class="nc" id="L316">        int revokedRemoved = refreshTokenRepository.deleteOldRevokedTokens(cutoffDate);</span>
        
<span class="nc" id="L318">        int totalRemoved = expiredRemoved + revokedRemoved;</span>
<span class="nc" id="L319">        logger.info(&quot;Limpeza manual concluída: {} tokens removidos&quot;, totalRemoved);</span>
        
<span class="nc" id="L321">        return totalRemoved;</span>
    }

    /**
     * Busca tokens que expiram em breve para notificação.
     *
     * @return Lista de tokens que expiram nos próximos 7 dias
     */
    public List&lt;RefreshToken&gt; getTokensExpiringSoon() {
<span class="nc" id="L330">        LocalDateTime now = LocalDateTime.now();</span>
<span class="nc" id="L331">        LocalDateTime soonDate = now.plusDays(7);</span>
<span class="nc" id="L332">        return refreshTokenRepository.findTokensExpiringSoon(now, soonDate);</span>
    }

    /**
     * Busca tokens inativos (não usados há mais de 30 dias).
     *
     * @return Lista de tokens inativos
     */
    public List&lt;RefreshToken&gt; getInactiveTokens() {
<span class="nc" id="L341">        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(30);</span>
<span class="nc" id="L342">        return refreshTokenRepository.findInactiveTokens(cutoffDate);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>